{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block main %}
    <h1>Report</h1>
    <div class="report-container">
        <div class="report-text">
            <section id="kmom01">
                <h2>Kmom01</h2>
                <p>
                    Jag kom i kontakt med objektorienterad programmering först i slutet av JS-kursen
                    och därefter mer på djupet i oopython-kursen. Det som jag uppskattar mest med
                    objektorienterad programmering är att det finns stora möjligheter till strukturerad kod
                    och möjligheter att återanvända kod. Det jag har med mig från tidigare kurser är att
                    jag kan skapa klasser av vilka jag kan instansiera objekt som har tillgång till
                    klassens medlemsvariabler och medlemsmetoder. I den här kursen och i ramverket Symfony
                    (med php som bas) har jag förstått att vi, genom autoloader och namespaces,
                    får tillgång till klasser/funktioner/filer utan att skriva include överallt.
                    Nyckelordet "use" är din kamrat.
                </p>
                <p>
                    För att skapa en klass behövs inte mer än nyckelordet "class" och måsvingar.
                    Inuti klassen, precis som andra programmeringsspråk jag har stött på, kan vi
                    definiera variabler och metoder som tillhör klassen. Vill man instansiera ett objekt
                    av klassen deklarerar man en variabel och tilldelar variabeln en ny instans av klassen,
                    med nyckelordet "new" följt av klassnamnet. Vill man att koden ska vara tillgänglig utifrån
                    sätter vi nyckelordet "public" framför en metod eller variabel, medan "protected" och "privat"
                    är av mer skyddande karaktär, där "protected" tillåter arv klasser emellan.
                </p>
                <p>
                    Ju mer jag har suttit med koden, desto mer har jag förstått den, naturligtvis.
                    Jag skapar klasser som förlängningar av redan skapade klasser för att skapa routes.
                    Med hjälp av AbstractController-klassen kan jag förlänga en egenskapad klass,
                    i vilken jag har möjlighet att använda mig av AbstractController-klassens render-metod.
                    Med denna metod kan jag rendera innehåll till twig-templates. Mina klasser har jag placerat
                    i olika controller-filer i src-mappen (C:et i MVC). Template-filerna som jag renderar innehåll
                    till är placerade i templates-mappen. Under assets-mappen finns mina style sheets och även
                    applikationens huvudsakliga js-fil (app.js). Jag tycker att strukturen inte är helt olik
                    den strukturen jag jobbade med i design-kursen när vi arbetade i pico och även hur vi
                    arbetade i webtec-kursen med vyer och controllers. Detsamma gäller väl även oopython-kursen och
                    databas-kursen måste jag väl ändå tillägga. Ja, nu förstår jag såklart att upplägget med den här
                    typen av struktur är återkommande. Det är inte exakt samma struktur men det finns en tydlig
                    struktur. 
                </p>
                <p>
                    Jag har inte hunnit läsa hela PHP: The Right Way, utan bara skannat av den på ytan. Däremot
                    är det inte svårt att utifrån rubrikerna se en hel del intressanta områden. Två av områdena
                    som jag kommer fördjupa mig i är "Security" och "Servers and Deployment". Vi har än så länge
                    pratat ytligt om säkerhet, bland annat i jämförelsen GET vs. POST, användandet av frågetecken
                    i SQL-frågor i värdspråk (såsom just PHP och JavaScript) samt i jämförelsen mellan ett flat
                    file cms jämfört med en databas. Här skulle jag vilja fördjupa mina kunskaper för att kunna
                    skapa säkra betalningslösningar och inloggningslösningar i applikationer. 
                    Nu har vi snart läst halva utbildningen och vi har jobbat lokalt och mot studentservern. Hur
                    gör vi när vi ska deploya IRL, dvs. utan hjälp av dbwebb och studentservern? Det vill jag lära
                    mig snarast.
                </p>
                <p>
                    Min TIL för den här veckan är vad klassen AbstractController bidrar med. Än så länge har jag/vi
                    använt den för att få tillgång till metoden render().
                </p>
                <p>
                    Tack för den här veckan /Martin
                </p>
            </section>
            <section id="kmom02">
                <h2>Kmom02</h2>
                <p>
                    Inom objektorientering används begreppen arv (inheritance), komposition, interface och
                    trait. Arv handlar om att en klass ärver (extends) en annan klass, dvs. har tillgång
                    till dess egenskaper (properties) och beteenden (methods). Komposition handlar om att en
                    klass har/använder sig av en annan klass, det kan iscensättas med nyckelordet use.
                    Interface är som ett kontrakt av metoder, där klasser som implementerar interfacet förbinder
                    åtar sig att hedra kontraktet och implementera just de metoder interfacet beskriver.
                    Interfacet konstruerar inga metoder, utan listar dem bara kan man säga. Ett trait mer som en klass
                    som innehåller deklarerade variabler och metoder som andra klasser kan använda. Ett trait
                    skapas för att återanvända kod, likt en modul eller en klass. Fördelen med trait är att det går
                    att en klass kan använda flera traits, medan en klass, i PHP, endast kan ärva från EN annan klass.
                </p>
                <p>
                    Jag är inte nöjd med min implementation av uppgiften. Jag krånglade till det för mycket.
                    Mina routes är belamrade med kod, inte snygg kod alls. Jag fastnade mycket i logiken och alla
                    olika håll som koden kunde ta vägen. Det slutade med en rörig logik och inte stabil applikation.
                    Jag tar gärna emot konstruktiv kritik på koden.
                    Jag tänkte att jag har en Deck-klass och en Card-klass.
                    Card-klassen använder Deck-klassen för att skapa en kortlek.
                    Klassernas metoder är snarlika (kanske skulle använt trait eller extendat?).
                    Card-klassens metoder används i Card-controllern,
                    medan Deck-klassens metoder används i Api-controllern. Det blev alltså en struktur
                    av det men jag har redan lagt ner för mycket tid på det och känner att jag behöver
                    gå vidare. Jag får dra mina lärdomar av detta som jag beskriver i kommande stycken.
                </p>
                <p>
                    Den goda idén att jobba med flödesschema glömde jag helt. Jag skrev pseudokod och
                    lyckades med det tillvägagångssättet lösa uppgiften. Nu i efterhand hade säkert
                    ett flödesschema hjälpt mycket i att inte skapa en djungel i mina controllers.
                    Det känns som att för mycket av logiken i mina spel hamnar i controllern. Kanske
                    hade varit bättre att skapa fler metoder eller åtminstone förfina dem för att slippa
                    ha så mycket kod i router-funktionerna/-metoderna.
                </p>
                <p>
                    Min TIL för detta kursmoment är att rita, skissa och ta ett helhetsgrepp på koden med
                    hjälp av pseudokod och flödesschema innan jag börjar koda. Det var ett tufft kmom
                    vars innehåll jag verkligen vill bemästra framöver. Kampen fortsätter.
                </p>
                <p>
                    Mvh Martin
                </p>
            </section>
            <section id="kmom03">
                <h2>Kmom03</h2>
                <p>
                    Jag tyckte att flödesdiagrammet och pseudokoden, trots att jag gjorde dem ganska
                    ytliga, var till stor hjälp i att hitta en struktur för mitt spel.
                    Det som också hjälpte mig var att skriva upp följande flöde: ett spel har en kortlek,
                    spelare, regler och spellogik. En spelare har ett namn, poäng och en hand (med kort).
                    En hand har kort. Det gjorde att jag snabbt kunde identifiera klasserna som spelet
                    behövde enligt mig. Även om flödesdiagrammet och pseudokoden inte är av bästa
                    kvalitet, tycker jag att det hjälpte mig att starta igång processen att problemlösa
                    fram spelet. Det blev som en gnista, som hjälpte spelet att växa.
                </p>
                <p>
                    Utifrån mina tankar, som jag beskriver ovan, kunde jag börja skapa mina klasser.
                    Jag började med att skapa klasserna för reglerna, spelaren, handen och poängen. Poäng-klassen
                    spenderade jag mest tid på (förutom själva spel-klassen). Det var inte helt klart
                    från början hur jag skulle lösa beräkningen av ess på hand och hur jag skulle
                    visa poängen (höga och låga poäng) live under spelets gång. Jag skrev en lång switch
                    case-sats med möjliga utfall för essen, men kunde se ett mönster i det som gjorde att
                    jag kunde korta ner koden avsevärt. När alla klasser var klara, kände jag att det även
                    behövdes en Bank-klass som var en förlängning av Player-klassen, med en extrametod för att
                    kolla om banken hamnat över 17 poäng. Game-klassen följde därefter med spelets logik.
                    Utifrån koden jag tidigare skrivit i övriga klasser, kunde jag hitta ett ok flöde i
                    Game-klassen. Jag är ganska nöjd ändå, med tanke på att det var det första objektorienterade
                    programmet som jag skapat från grunden och utan tips på klasser och metoder (som vi fick i
                    projektet i oopython-kursen). Förbättringspotentialen jag ser rör definitivt Game-klassen
                    och spellogiken. Det blev inte det där fina flödet som jag hade sett framför mig från
                    start. Det jag däremot är nöjd med är standings-variabeln i Game-klassen som håller all
                    information om spelet. Med bland annat hjälp av den kunde jag hålla koden i controllern
                    till ett minimum. Mina twig-filer kunde jag också hålla rätt smala, men där finns säkert
                    förbättringspotential, även om den mesta av logiken sköts i klasserna.
                </p>
                <p>
                    Jag förknippar ramverk bara med positiva saker, än så länge. Jag tycker att det är
                    tryggt att jobba med tydliga ramar som gör att jag inte behöver ta beslut om
                    till exempel hur mappstrukturen för min applikation ska se ut. Jag får allt med några
                    enkla knapptryck och kan dessutom fylla min composer.json med fler dependencies för
                    att göra appplikationen än mer vass.
                </p>
                <p>
                    Min TIL för detta kursmoment är hur phpstan fungerar. Jag tog mig ända upp till level
                    8, vilket jag är stolt över. Level 9 innebar en hel del förändringar på saker som jag
                    hade arbetat undan på tidigare nivåer. En lärdom att dra är att ha bättre koll på vad
                    jag kommer att stöta på i valideringen med composer lint för att försöka minimera
                    valideringsfelen samt validera oftare för att inte behöva ändra om för mycket i
                    min kod med risken att skapa följdfel/-problem.
                </p>
                <p>
                    Tack för den här omgången, Mvh Martin
                </p>
            </section>
            <section id="kmom04">
                <h2>Kmom04</h2>
                <p>
                    Så, dags att lämna in kmom04. Jag inser när jag skriver testerna och när
                    jag läser litteraturen kring testning att det är viktigt och hur det kan
                    förebygga massiv huvudbry längre fram i projekt. Jag tycker att det var lätt
                    att sätta mig in i PHPUnit och det liknade det vi gjorde i oopython-kursen
                    väldigt mycket. Ingen större skillnad egentligen. Det var även lätt att skapa
                    min egen konfiguration i xml-filen, där jag exkluderade vissa kataloger och
                    filer.
                </p>
                <p>
                    Jag lyckades nå över 90% kodtäckning men jag skulle inte säga att jag har
                    lyckats väl. Dels är min kod inte särskilt testbar (inte enligt mig själv i
                    alla fall), i Game-klassen är nästan samtliga metoder ihopkedjade, dvs. en
                    metod anropas och den anropar i sin tur nästa metod, som anropar nästa osv.
                    Jag hade väldigt svårt att hitta ett sätt att isolera metoderna och jag satt
                    länge och funderade och försökte bygga om koden.
                </p>
                <p>
                    Som jag skrev, tycker jag inte att huvudparten av min kod är testbar kod.
                    Självklart finns det delar som går att förbättra. Jag hade kunnat
                    placera mer kod i min game-controller. På så vis hade jag byggt upp en kodbas där
                    metoder inte är ihopkedjade, utan där varje metod gör en return. Det hade blivit
                    en renare approach rent testmässigt, även om controllern hade blivit fetare.
                </p>
                <p>
                    Jag skrev om min kod på vissa ställen, la till några metoder. Till exempel i
                    game-klassen skapade jag en getGameState-metod (enligt tips från mos), som
                    jag använde när jag testade metoderna i game-klassen. "Problemet" med game-
                    klassen var ju dock att flera metoder anropades även om jag bara ville testa
                    en av dem. getGameState-metoden fyllde ett visst syfte, men jag vet inte om
                    hela test-suiten bara blev ett korthus, ett fejkat test för att nå högre
                    kodtäckning. En sak jag gjorde för att ändå få lite mindre variation i
                    testningen var att uppdatera shuffle-metoden i Deck-klassen med en
                    optionell parameter "seed" som gjorde att kortleken alltid blandades på exakt
                    samma sätt så länge seed-värdet var samma. På så vis kunde jag också lätt
                    simulera ess på hand och andra metoder i övriga klasser.
                </p>
                <p>
                    Testbar kod kan absolut vara en markör för snygg och ren kod.
                    Genom att till exempel inte chaina mina metoder i game-klassen och
                    låta dem utföra sitt arbete och därefter returnera ett värde eller uppdatera
                    en property, hade det varit lättare att testa koden och det hade varit lättare
                    också att se vart koden leder.
                </p>
                <p>
                    Min TIL för detta kmom är följande: I framtiden vill jag för projekt eller
                    uppgifter (kod) som behöver testas skriva testfall innan jag börjar skriva
                    själva koden. Det hade, för mig, varit en bättre approach om jag hade jobbat
                    TDD redan från början. Nu tog jag mig inte tiden, av olika anledningar, att
                    arbeta om min kod. Det hade i och för sig varit en bra läxa, men i brist av tid
                    valde jag att inte lägga något krut på det. Må hända att jag får Ux på grund av
                    mina bristfälliga test suites och då får jag helt enkelt tänka om.
                </p>
                <p>
                    Mvh Martin
                </p>
            </section>
            <section id="kmom05">
                <h2>Kmom05</h2>
                <p>
                    Ja, det gick bra att genomföra övningen. Jag tyckte det var lätt att sätta sig
                    in i tack vare databas-kursen. Jag reagerade inte över någonting särskilt, mer
                    än att det var väldigt lätt att skapa en tabell (entity) och tabell-kolumnerna
                    med terminal-kommandon.
                </p>
                <p>
                    Jag skapade en landningssida (library) från vilken samtliga sidor i appen
                    är tillgängliga. Precis som i tidigare kursmoment, genererade jag url till
                    sidan för att använda dem i ett formulär med en knapp för varje sida i appen.
                    Jag tänkte att det ska vara enkelt att komma åt olika sidor och funktioner
                    inuti sidorna. Där skapade jag knappar för att komma till alla böcker,
                    landningssidan (main menu) och för att klicka sig mellan böcker (previous och
                    next-knappar). Jag tyckte att det behövdes en confirm delete-sida för att ge
                    användaren en chans att ångra sig innan en bok tas bort. Gränssnittet i övrigt
                    liknar resten av min symfony-applikation där mycket av stylingen är
                    återkommande. Jag hittade även unicode-karaktärer som jag använde mig av
                    i knapparnas text.
                </p>
                <p>
                    Jag tycker att det gick bra att jobba med ORM (CRUD). Nu valde jag att placera
                    all kod i min BookController. Snyggast, enligt mig, hade varit att placera
                    en del av koden i andra klasser eller bookrepot, t.ex. koden som ändrar
                    i databasen hade kunnat placeras i bookrepot och koden som jag återanvänder
                    för att fastställa föregående och nästa bok hade kunnat placeras i en egen
                    klass eller trait. CRUD i ORM var smidigt då Book-entityn automatiskt skapat
                    metoder för att "getta" och "setta" värden i tabellen. Om jag jämför det med
                    databas-kursen och webtec-kursen, fick vi skriva alla förfrågningar mot databasen
                    från grunden. ORM-approachen kapar en del mellansteg, vilket skapar en effektivare
                    process. Om jag vill ha fler metoder än de som erbjuds i entity-klassen eller
                    repot, kan jag enkelt lägga till dem.
                </p>
                <p>
                    ORM verkar kanon än så länge och det ska bli kul att lära sig mer om det i
                    prjektet! All kod vi behövde skriva i databas-kursen (både sql och javascript),
                    är ju klart minimerat tack vare ORM-sättet att arbeta med en databas. Jag ville
                    verkligen lyckas kicka igång mariadb istället för sqlite, men jag fick inte riktigt
                    till det. Tycker att sqlite fungerade tillräckligt bra för den här rundan.
                </p>
                <p>
                    Min TIL för den här veckan är doctrine/orm och förståelsen för hur alla auto-
                    magiskt skapade filer hänger ihop. Det var även kul att skapa logiken bakom
                    previous och next book.
                </p>
                <p>
                    Mvh Martin
                </p>
            </section>
            <section id="kmom06">
                <h2>Kmom06</h2>
                <p>
                    Det var svårt till en början att förstå alla mått och få grepp om
                    metrics-rapporten. Jag försökte fokusera på 6C som uppgiften handlade om, vilket
                    gjorde det lättare. När det väl hade lossnat kunde jag lättare hitta rätt mått
                    och analysera rapporten. Metrics-verktyget gav inte lika handfasta tips som
                    scrutinizer, men genom att läsa på om de olika värdena var det inte svårt
                    att hitta lämpliga åtgärder. Det jag mest uppskattade med verktyget var ändå
                    bilden med de olika klasserna visualiserade som gröna, gula och röda bollar.
                    Bilden gav en överblick och känsla för vilka delar av koden som var mest akuta
                    att jobba med.
                </p>
                <p>
                    Det gick ändå ok att få till Scrutinizer. Det failade några gånger innan jag hittade
                    en webbsida som förklara vad jag skulle göra åt failen. Min känsla är att
                    Scrutinizer inte är lika heltäckande som phpmetrics, vilket gjorde verktyget lite
                    lättare att förstå och rapporten lättare att hitta i. Det var roligt att få min
                    kod "bedömd", jag fick en känsla för om jag hade gjort ett bra jobb från början
                    eller inte. Scrutinizer var lite snällare i sin bedömning tycker jag, det lyste
                    mer rött i phpmetrics.
                    Jag landade på över 9 i kodkvalitet och strax över 70% i kodtäckning efter
                    första bygget. Efter sista bygget landade jag på 10 respektive 78%.
                </p>
                <p>
                    EDIT! Insåg att jag hade glömt att ta bort exkluderingen av src/Controller.
                    Inte konstigt att kodtäckningen var så hög. Exkluderade dock src/Entity och
                    src/Repository, för tillfället i alla fall. Inför projektinlämningen är min
                    ambition att nå högre kodtäckning i src/Controller till att börja med.
                    Kanske ger jag mig på att göra enhetstester även för Entity- och
                    Repository-klasserna. Med denna ändring landar kodtäckningen för min del på
                    blygsamma 37%.
                </p>
                <p>
                    Eftersom jag har arbetat själv genom alla kurser, har jag inte reflekterat särskilt
                    mycket kring kodkvalitet och snygg kod. Däremot förstår jag att det är en
                    särskilt viktig aspekt i utveckling av programvara när en jobbar i ett team,
                    oavsett litet eller stor. Vikten av att koden är lättläst och lättförståelig ökar
                    med storleken på ett projekt och antalet människor som arbetar inom projektet.
                    Gemensam kodstil, testbar kod, linters och analysverktyg måste vara del av alla
                    projekt. Jag tänker att det bara leder till ett effektivare arbete, mindre
                    efterarbete och minskad risk för koststamma buggar i produktion.
                </p>
                <p>
                    Min TIL för det här kursmomentet är hur jag kan använda Scrutinizer och PHPMetrics
                    för att analysera och förbättra min kod.
                </p>
            </section>
            <section id="kmom10">
                <h2>Kmom10/Projekt</h2>
                <p>
                    Hej!
                </p>
                <p>
                    Här kommer min redovisningstext för projektet i mvc-kursen. Tack för ett bra läsår,
                    ha en fortsatt fin sommar. Mvh Martin
                </p>
                <h3>Kraven 1-6</h3>
                <p>
                    KRAV 1-3
                    <br><br>
                    Som projekt i mvc-kursen har jag valt att göra ett texas hold'em-spel. Jag valde det spåret
                    för att jag har spelat mycket texas hold'em. Jag ville försöka komma så nära den äkta
                    spelkänslan som möjligt, om ens en bråkdel. I början var jag helt inställd på
                    den populära all-in-varianten, men valde till slut limit hold'em. Enkelheten i limit-spelet,
                    gjorde att jag kunde fokusera på andra, för mig viktigare, features.
                    <br><br>
                    Ett av projektets huvudfokus har varit att leverera en pricksäker jämförelse-mekanism som
                    helst ska ha 0 luckor. Metoden som tar fram alla kombinationer av möjliga femkortshänder,
                    metoderna som identifierar vilken pokerhand respektive kombination är och metoderna som
                    beräknar poängen för en enskild kombination har varit centrala i just detta fokus. Varför har jag
                    lagt ner mest tid på det här? Jo, för att syftet med spelet är att (ha kul och) vinna, vilket
                    innebär att jag som spelare inte vill att vinst/förlust ska avgöras genom felaktigheter.
                    <br><br>
                    Jag har använt analysverktygen (metrics, scrutinizer) och gjort tester från första början
                    för att skriva så "snygg" kod som möjligt. Från början hade jag ett bra flow i att skapa
                    flera, mindre klasser och controllers, men känner nu i slutet att vissa av dem är alltför
                    komplexa. TexasGame-klassen har återigen blivit ett äkta gudobjekt med 29 metoder.
                    Samma utmaning som jag stötte på i black jack-spelet alltså, även om jag nu har
                    en mer testvänlig kodbas.
                    <br><br>
                    I Scrutinizer får alla klasser och metoder betyget A, utom TexasGame-klassen som får B.
                    Metrics visar gult och rött på många fler ställen. Jag har flera klasser, förutom TexasGame,
                    som är riktigt tjocka och metoder som är för komplexa.
                    <br><br>
                    Mot slutet har jag också prioriterat bort testningen, framförallt i TexasGame-klassen. Jag landar
                    på en kodtäckning på ca 90%, vilket enbart är baserat på Texas-mappen i src-katalogen.
                    Däremot tycker att jag har kommit ytterligare en bit på vägen i att lära mig testning. Det var
                    en välbehövlig fortsättning på det vi lärde oss i oopython.
                    <br><br>
                    Jag har för mitt projekt satsat på ett utseende baserat mestadels på projektinnehållet.
                    Header-bildens färger har jag använt som grund. Jag tycker att bilden innehåller de dova
                    och mörka färgerna som jag förknippar med texas hold'em. Dessa har jag försökt
                    återanvända på sidan för att få en helhet.
                    <br><br>
                    Jag har jobbat med SASS, vilket har gjort styling-arbetet i projektet till
                    en lättsammare arbetsuppgift. Mina style-sheets är uppdelade i två kategorier:
                    element-specifika och sidospecifika. Det har gjort sökandet effektivare. Möjligheten
                    att jobba med variabler är en annan anledning till varför jag valde SASS.
                    <br><br>
                </p>
                <p>
                    KRAV 4
                    <br><br>
                    Jag hade API:et i åtanke när jag jobbade med projektet. Jag ville att det skulle vara lätt
                    att visa spel- och spelardata till exempel. Därför finns till exempel game data-klassen och
                    getPlayerData-metoden i spelarklasserna.
                    <br><br>
                    Mitt JSON API för projektet landade i fem stycken välutvalda endpoints.
                    <br><br>
                    Två av mina endpoints, api/game-data och api/player-data, hämtar data från spelet med hjälp
                    av ovannämnda klass och dess metoder och getPlayerData-metoden.
                    <br><br>
                    Två andra endpoints, api/card-rank och api/message-data, är POST-routes som jobbar
                    mot projektets databastabeller. Ena tabellen innehåller alla 169 kombinationer av startkort.
                    Den andra innehåller alla meddelanden från pågående spel.
                    <br><br>
                    För att nå dessa endpoints, får användaren fylla i:
                    1. Valfri kortranking (1-169) för två startkort
                    eller
                    2. Valfritt antal meddelanden (1-10) från pågående spel.
                    <br><br>
                    Den femte endpointen jobbar mot CardCombinator-klassen och HandEvaluator-klassen.
                    Om det finns ett pågående spel där rivern är ute, går det att använda endpointen för att
                    se ens samtliga 21 kombinationer av femkortshänder som kan bildas med ens
                    två kort på hand och de fem gemensamma korten på bordet.
                    Kombinationerna är sorterade så att den starkaste handen är högst upp.
                    Här avslöjas även vad respektive kombination är för pokerhand (ett par, två par, osv..).
                    <br><br>
                    Om det inte finns ett spel igång som är framme vid rivern (alla fem kort på bordet), visar
                    endpointen alla 21 kombinationer för sju random-kort.
                    <br><br>
                </p>
                <p>
                    KRAV 5
                    <br><br>
                    Jag valde att arbeta med SQLITE som databashanterare. Det var enkelt att köra igång under
                    kursens gång och jag såg ingen direkt anledning till att testa någonting annat då databasen
                    i det här fallet är väldigt simpel.
                    <br><br>
                    Projektets entities/tabeller är två till antalet. En rankingtabell för samtliga 169
                    startkorts-kombinationer och en meddelandetabell som håller data för vad som händer
                    under spelets gång.
                    <br><br>
                    Att arbeta med ORM har varit relativt smärtfritt, tycker jag. Väldigt smidigt att direkt via
                    consolen och doctrine-kommandon kunna skapa tabellerna. Nackdelen blir då att jag ändå måste
                    skapa sql-kommandon för återställning av databasen, antingen hårdkodat i en controller eller
                    via en fil.
                    <br><br>
                    Jag valde att populera databasens kortranking-tabell via en csv-fil och ett eget-skapat kommando
                    csv:import, vilket kändes som en krångligare väg att göra det på än det sättet vi gick tillväga
                    under databas-kursen, med enkla insert-kommandon i fil.
                    <br><br>
                    En fördel med att arbeta med ORM är hur lätt det är att hämta data med hjälp av färdiga eller
                    egenbyggda metoder i respektive entity-repo. Metoderna är som en blandning av metoderna vi
                    byggde i JS och sql-koden vi skrev i fil i databaskursen. Det blir som ett mer
                    lättillgängligt api.
                    <br><br>
                </p>
                <p>
                    KRAV 6
                    <br><br>
                    Detta med avancerat är väl subjektivt, så det blir spännande att se vad rättaren tycker.
                    Här kommer mina avancerade features, även om de tekniskt sett skulle kunna räknas som del
                    av baskraven.
                    <br><br>
                    1. Kortkombinationer:
                    <br>Jag är tacksam för att ha jobbat med rekursiva metoder i oopython-
                    kursen. Tveksamt om jag hade kommit på att skriva min kombinations-metod på det sättet annars.
                    Metoden används för att hitta samtliga kombinationer som spelarna kan få med sina två kort på hand
                    och tre-fem gemensamma kort på bordet. Metoden anropas med två argument. Det första en array
                    med kort-objekt och den andra antalet kort i varje kombination (satt till 5 som default).
                    <br><br>
                    Kombinationerna används för att fastställa spelarnas
                    bästa hand: dels för att kunna utse en vinnare, dels som en service till spelaren som blir visad
                    sin bästa hand under spelets gång och dels för att ha en endpoint med intressant data.
                    <br><br>
                    2. Beräkning av handpoäng:
                    <br>Varje evaluatorklass som implementerar EvaluatorInterface måste
                    tillhandahålla en poäng-metod. Metoderna använder sig av konstanterna i en abstrakt klass.
                    Jag placerade konstanterna i den abstrakta klassen för att samtliga evaluatorklasser
                    behöver ha samma information. Då blev det också lättare att bara ändra på ett ställe, för
                    det fick jag göra ända in i slutet. Till en början trodde jag att jag hade kommit
                    på ett bra poängsystem, där varje hand får en grundpoäng för pokerhanden (ett par, två par, osv..).
                    Men när jag fyllde ut mina tester med fler case, kunde jag se att poängberäkningen inte
                    tog hänsyn till alla parametrar i en pokerhand. Till exempel kunde en hand med par i treor
                    förlora mot en hand med par i tvåor, för att handen med tvåorna hade starkare kickers
                    (övriga kort). Eller om två spelare har samma par till exempel, så ska spelaren med högst
                    kickers vinna.
                    <br><br>
                    Därför fick jag justera upp grundpoängen för varje hand till biljonklassen och
                    för varje evaluator skapa en ny metod som beräknar värdet av varje kicker. Här behövde
                    jag se till att värdet av ett kort alltid måste överstiga värdet av samtliga lägre kort.
                    Jag behövde också skapa en algoritm i poängmetoden som på något sätt ökar poängen för
                    värdekorten (paren, trissen, fyrtalet osv.) på så vis att poängen för kickerkorten aldrig
                    kan trumfa värdekorten.
                    <br><br>
                    Det tog lång tid och tog och timmar av testning för att hitta rätt.
                    Nu beräknas poängen korrekt och rätt hand ska alltid vinna.
                    <br><br>
                    3. Den smarta datorspelaren:
                    <br>Den sista avancerade featuren som jag vill ta upp är den smarta
                    datorspelaren. Den kan tyckas vara del av baskraven. Jag tycker dock att den är avancerad,
                    dels för att det ligger många tankar och mycket kodning bakom och för att
                    den tar sina beslut utfrån ett antal olika kriterier. Det är även lätt att justera
                    kalkylerna som adderar ihop till riksbenägenheten. 
                    <br><br>
                    Den smarta datorspelarens riskbenägenhet tar hänsyn till vilka startkort den har,
                    genom att hämta rankingen för sina två startkort från databastabellen.
                    Den har koll på dina senaste moves och justerar risknivån därefter. Om du till
                    exempel checkar och sen höjer i samma spelstadie (t.ex. pre-flop), sänks
                    spelarens riskbenägenhet. Om du bara checkar/synar, höjs riskbenägenheten. Kort på hand
                    och vilken femkortshand spelaren har väger dock lite tyngre. Den tar även hänsyn till
                    förhållandet mellan big blind och pot. Ju mindre andel av potten en big blind är desto
                    högre blir riskbenägheten.
                    <br><br>
                </p>
                <h3>Genomförandet av projektet</h3>
                <p>
                    Jag valde att inte lämna in innan deadline den här gången, då jag ville prova på att
                    koda utan tidspress. Det har jag velat länge och tycker att det var helt rätt beslut.
                    Jag har suttit i princip varje dag sedan inlämningen av kmom06, så det har tagit sin tid.
                </p>
                <p>
                    Den största huvudbryn har varit hur jag ska kunna minimera antalet redirects
                    när användaren har foldat och spelet kastas runt mellan datorspelarnas olika vägar
                    genom olika controllers och routes. Även om användaren landar rätt till slut
                    (i Chrome, ej FireFox), känns det aldrig bra att mellanlanda på en sida som klagar
                    på för många redirects.
                    <br><br>
                    Ett alternativ hade varit att göra router-metoderna tjockare och färre. Jag valde inte
                    det alternativet. Istället låter jag spelet spelas klart när användaren lägger sig.
                    Användaren skickas direkt till en sida där vinnaren mellan datorspelarna är utsedd
                    och presenteras. Den enda skillnaden mellan alternativen är att potterna har olika
                    storlek.
                    <br><br>
                </p>
                <p>
                    Det har varit många sådana beslut att ta och jag tycker att jag har lyckats få till ett
                    ok spel. Jag har fastnat vid något tillfälle och hamnat på minus.. Ja, det går att hamna
                    minus. Datorspelarna får dock autopåfyllning. Så spelet har inget faktiskt slut...
                    <br><br>
                    Jag hade aldrig kunnat skapa ett texas hold'em-spel på den tid jag hade innan
                    deadline. Inte ett som jag hade varit nöjd med i alla fall. Det känns som att fler har valt
                    att låta något av projekten hänga på över sommaren. Jag är glad att jag gjorde det.
                    <br><br>
                </p>
                <h3>Tankar om kursen</h3>
                <p>
                    Kursen var den svåraste hittills, framförallt var projektet en utmaning att få ihop.
                    Kursen knyter ihop första läsåret på ett bra sätt. Jag känner att jag under kursens gång har fått
                    användning av mycket av det jag har lärt mig under året. Nu fick vi däremot göra det i ett
                    ramverk. Det finns likheter med webtec-kursen, vilket är tacksamt. Jag har fått repetera
                    CRUD och designmönstret MVC. Dessutom gjorde designkursen ett gott intryck på mig. Jag har
                    haft god användning av det jag lärde mig där också.
                <br><br>
                    Tips till programansvarig: lär ut css grid och/eller css flex första läsperioden. Lätt det bästa
                    jag lärt mig under året.
                </p>
                <p>
                    Det har varit informativa artiklar i kursmaterialet och bra hänvisningar till andra
                    källor.
                </p>
                <p>
                    Mikaels förinspelade föreläsningar har varit en bra start på kursmomenten.
                    Tisdagsföreläsningen tar upp det viktigaste i kursmomentet och Mikael går igenom
                    övningarna i bra takt.
                </p>
                <p>
                    Hjälp finns alltid att få på Discord.
                    Alla kurskamrater som hjälper till ska ha en eloge.
                </p>
                <p>
                    Jag är nöjd och har lärt mig mycket!
                </p>
                <p>
                    Mvh Martin
                </p>
            </section>
        </div>
        <div class="report-links">
            <h3 class="sections">Avsnitt</h3>
            <div class="report-link">
                <a href="{{ path('report') }}#kmom01">kmom01</a>
                <a href="{{ path('report') }}#kmom02">kmom02</a>
                <a href="{{ path('report') }}#kmom03">kmom03</a>
                <a href="{{ path('report') }}#kmom04">kmom04</a>
                <a href="{{ path('report') }}#kmom05">kmom05</a>
                <a href="{{ path('report') }}#kmom06">kmom06</a>
                <a href="{{ path('report') }}#kmom10">kmom10</a>
            </div>
            <a class="back-to-top" href="{{ path('report') }}#header">
                <h3>Upp till toppen</h3>
            </a>
        </div>
    </div>
{% endblock %}