{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block main %}
    <h1>Report</h1>
    <div class="report-container">
        <div class="report-text">
            <section id="kmom01">
                <h2>Kmom01</h2>
                <p>
                    Jag kom i kontakt med objektorienterad programmering först i slutet av JS-kursen
                    och därefter mer på djupet i oopython-kursen. Det som jag uppskattar mest med
                    objektorienterad programmering är att det finns stora möjligheter till strukturerad kod
                    och möjligheter att återanvända kod. Det jag har med mig från tidigare kurser är att
                    jag kan skapa klasser av vilka jag kan instansiera objekt som har tillgång till
                    klassens medlemsvariabler och medlemsmetoder. I den här kursen och i ramverket Symfony
                    (med php som bas) har jag förstått att vi, genom autoloader och namespaces,
                    får tillgång till klasser/funktioner/filer utan att skriva include överallt.
                    Nyckelordet "use" är din kamrat.
                </p>
                <p>
                    För att skapa en klass behövs inte mer än nyckelordet "class" och måsvingar.
                    Inuti klassen, precis som andra programmeringsspråk jag har stött på, kan vi
                    definiera variabler och metoder som tillhör klassen. Vill man instansiera ett objekt
                    av klassen deklarerar man en variabel och tilldelar variabeln en ny instans av klassen,
                    med nyckelordet "new" följt av klassnamnet. Vill man att koden ska vara tillgänglig utifrån
                    sätter vi nyckelordet "public" framför en metod eller variabel, medan "protected" och "privat"
                    är av mer skyddande karaktär, där "protected" tillåter arv klasser emellan.
                </p>
                <p>
                    Ju mer jag har suttit med koden, desto mer har jag förstått den, naturligtvis.
                    Jag skapar klasser som förlängningar av redan skapade klasser för att skapa routes.
                    Med hjälp av AbstractController-klassen kan jag förlänga en egenskapad klass,
                    i vilken jag har möjlighet att använda mig av AbstractController-klassens render-metod.
                    Med denna metod kan jag rendera innehåll till twig-templates. Mina klasser har jag placerat
                    i olika controller-filer i src-mappen (C:et i MVC). Template-filerna som jag renderar innehåll
                    till är placerade i templates-mappen. Under assets-mappen finns mina style sheets och även
                    applikationens huvudsakliga js-fil (app.js). Jag tycker att strukturen inte är helt olik
                    den strukturen jag jobbade med i design-kursen när vi arbetade i pico och även hur vi
                    arbetade i webtec-kursen med vyer och controllers. Detsamma gäller väl även oopython-kursen och
                    databas-kursen måste jag väl ändå tillägga. Ja, nu förstår jag såklart att upplägget med den här
                    typen av struktur är återkommande. Det är inte exakt samma struktur men det finns en tydlig
                    struktur. 
                </p>
                <p>
                    Jag har inte hunnit läsa hela PHP: The Right Way, utan bara skannat av den på ytan. Däremot
                    är det inte svårt att utifrån rubrikerna se en hel del intressanta områden. Två av områdena
                    som jag kommer fördjupa mig i är "Security" och "Servers and Deployment". Vi har än så länge
                    pratat ytligt om säkerhet, bland annat i jämförelsen GET vs. POST, användandet av frågetecken
                    i SQL-frågor i värdspråk (såsom just PHP och JavaScript) samt i jämförelsen mellan ett flat
                    file cms jämfört med en databas. Här skulle jag vilja fördjupa mina kunskaper för att kunna
                    skapa säkra betalningslösningar och inloggningslösningar i applikationer. 
                    Nu har vi snart läst halva utbildningen och vi har jobbat lokalt och mot studentservern. Hur
                    gör vi när vi ska deploya IRL, dvs. utan hjälp av dbwebb och studentservern? Det vill jag lära
                    mig snarast.
                </p>
                <p>
                    Min TIL för den här veckan är vad klassen AbstractController bidrar med. Än så länge har jag/vi
                    använt den för att få tillgång till metoden render().
                </p>
                <p>
                    Tack för den här veckan /Martin
                </p>
            </section>
            <section id="kmom02">
                <h2>Kmom02</h2>
                <p>
                    Inom objektorientering används begreppen arv (inheritance), komposition, interface och
                    trait. Arv handlar om att en klass ärver (extends) en annan klass, dvs. har tillgång
                    till dess egenskaper (properties) och beteenden (methods). Komposition handlar om att en
                    klass har/använder sig av en annan klass, det kan iscensättas med nyckelordet use.
                    Interface är som ett kontrakt av metoder, där klasser som implementerar interfacet förbinder
                    åtar sig att hedra kontraktet och implementera just de metoder interfacet beskriver.
                    Interfacet konstruerar inga metoder, utan listar dem bara kan man säga. Ett trait mer som en klass
                    som innehåller deklarerade variabler och metoder som andra klasser kan använda. Ett trait
                    skapas för att återanvända kod, likt en modul eller en klass. Fördelen med trait är att det går
                    att en klass kan använda flera traits, medan en klass, i PHP, endast kan ärva från EN annan klass.
                </p>
                <p>
                    Jag är inte nöjd med min implementation av uppgiften. Jag krånglade till det för mycket.
                    Mina routes är belamrade med kod, inte snygg kod alls. Jag fastnade mycket i logiken och alla
                    olika håll som koden kunde ta vägen. Det slutade med en rörig logik och inte stabil applikation.
                    Jag tar gärna emot konstruktiv kritik på koden.
                    Jag tänkte att jag har en Deck-klass och en Card-klass.
                    Card-klassen använder Deck-klassen för att skapa en kortlek.
                    Klassernas metoder är snarlika (kanske skulle använt trait eller extendat?).
                    Card-klassens metoder används i Card-controllern,
                    medan Deck-klassens metoder används i Api-controllern. Det blev alltså en struktur
                    av det men jag har redan lagt ner för mycket tid på det och känner att jag behöver
                    gå vidare. Jag får dra mina lärdomar av detta som jag beskriver i kommande stycken.
                </p>
                <p>
                    Den goda idén att jobba med flödesschema glömde jag helt. Jag skrev pseudokod och
                    lyckades med det tillvägagångssättet lösa uppgiften. Nu i efterhand hade säkert
                    ett flödesschema hjälpt mycket i att inte skapa en djungel i mina controllers.
                    Det känns som att för mycket av logiken i mina spel hamnar i controllern. Kanske
                    hade varit bättre att skapa fler metoder eller åtminstone förfina dem för att slippa
                    ha så mycket kod i router-funktionerna/-metoderna.
                </p>
                <p>
                    Min TIL för detta kursmoment är att rita, skissa och ta ett helhetsgrepp på koden med
                    hjälp av pseudokod och flödesschema innan jag börjar koda. Det var ett tufft kmom
                    vars innehåll jag verkligen vill bemästra framöver. Kampen fortsätter.
                </p>
                <p>
                    Mvh Martin
                </p>
            </section>
            <section id="kmom03">
                <h2>Kmom03</h2>
                <p>
                    Jag tyckte att flödesdiagrammet och pseudokoden, trots att jag gjorde dem ganska
                    ytliga, var till stor hjälp i att hitta en struktur för mitt spel.
                    Det som också hjälpte mig var att skriva upp följande flöde: ett spel har en kortlek,
                    spelare, regler och spellogik. En spelare har ett namn, poäng och en hand (med kort).
                    En hand har kort. Det gjorde att jag snabbt kunde identifiera klasserna som spelet
                    behövde enligt mig. Även om flödesdiagrammet och pseudokoden inte är av bästa
                    kvalitet, tycker jag att det hjälpte mig att starta igång processen att problemlösa
                    fram spelet. Det blev som en gnista, som hjälpte spelet att växa.
                </p>
                <p>
                    Utifrån mina tankar, som jag beskriver ovan, kunde jag börja skapa mina klasser.
                    Jag började med att skapa klasserna för reglerna, spelaren, handen och poängen. Poäng-klassen
                    spenderade jag mest tid på (förutom själva spel-klassen). Det var inte helt klart
                    från början hur jag skulle lösa beräkningen av ess på hand och hur jag skulle
                    visa poängen (höga och låga poäng) live under spelets gång. Jag skrev en lång switch
                    case-sats med möjliga utfall för essen, men kunde se ett mönster i det som gjorde att
                    jag kunde korta ner koden avsevärt. När alla klasser var klara, kände jag att det även
                    behövdes en Bank-klass som var en förlängning av Player-klassen, med en extrametod för att
                    kolla om banken hamnat över 17 poäng. Game-klassen följde därefter med spelets logik.
                    Utifrån koden jag tidigare skrivit i övriga klasser, kunde jag hitta ett ok flöde i
                    Game-klassen. Jag är ganska nöjd ändå, med tanke på att det var det första objektorienterade
                    programmet som jag skapat från grunden och utan tips på klasser och metoder (som vi fick i
                    projektet i oopython-kursen). Förbättringspotentialen jag ser rör definitivt Game-klassen
                    och spellogiken. Det blev inte det där fina flödet som jag hade sett framför mig från
                    start. Det jag däremot är nöjd med är standings-variabeln i Game-klassen som håller all
                    information om spelet. Med bland annat hjälp av den kunde jag hålla koden i controllern
                    till ett minimum. Mina twig-filer kunde jag också hålla rätt smala, men där finns säkert
                    förbättringspotential, även om den mesta av logiken sköts i klasserna.
                </p>
                <p>
                    Jag förknippar ramverk bara med positiva saker, än så länge. Jag tycker att det är
                    tryggt att jobba med tydliga ramar som gör att jag inte behöver ta beslut om
                    till exempel hur mappstrukturen för min applikation ska se ut. Jag får allt med några
                    enkla knapptryck och kan dessutom fylla min composer.json med fler dependencies för
                    att göra appplikationen än mer vass.
                </p>
                <p>
                    Min TIL för detta kursmoment är hur phpstan fungerar. Jag tog mig ända upp till level
                    8, vilket jag är stolt över. Level 9 innebar en hel del förändringar på saker som jag
                    hade arbetat undan på tidigare nivåer. En lärdom att dra är att ha bättre koll på vad
                    jag kommer att stöta på i valideringen med composer lint för att försöka minimera
                    valideringsfelen samt validera oftare för att inte behöva ändra om för mycket i
                    min kod med risken att skapa följdfel/-problem.
                </p>
                <p>
                    Tack för den här omgången, Mvh Martin
                </p>
            </section>
            <section id="kmom04">
                <h2>Kmom04</h2>
                <p>
                    Så, dags att lämna in kmom04. Jag inser när jag skriver testerna och när
                    jag läser litteraturen kring testning att det är viktigt och hur det kan
                    förebygga massiv huvudbry längre fram i projekt. Jag tycker att det var lätt
                    att sätta mig in i PHPUnit och det liknade det vi gjorde i oopython-kursen
                    väldigt mycket. Ingen större skillnad egentligen. Det var även lätt att skapa
                    min egen konfiguration i xml-filen, där jag exkluderade vissa kataloger och
                    filer.
                </p>
                <p>
                    Jag lyckades nå över 90% kodtäckning men jag skulle inte säga att jag har
                    lyckats väl. Dels är min kod inte särskilt testbar (inte enligt mig själv i
                    alla fall), i Game-klassen är nästan samtliga metoder ihopkedjade, dvs. en
                    metod anropas och den anropar i sin tur nästa metod, som anropar nästa osv.
                    Jag hade väldigt svårt att hitta ett sätt att isolera metoderna och jag satt
                    länge och funderade och försökte bygga om koden.
                </p>
                <p>
                    Som jag skrev, tycker jag inte att huvudparten av min kod är testbar kod.
                    Självklart finns det delar som går att förbättra. Jag hade kunnat
                    placera mer kod i min game-controller. På så vis hade jag byggt upp en kodbas där
                    metoder inte är ihopkedjade, utan där varje metod gör en return. Det hade blivit
                    en renare approach rent testmässigt, även om controllern hade blivit fetare.
                </p>
                <p>
                    Jag skrev om min kod på vissa ställen, la till några metoder. Till exempel i
                    game-klassen skapade jag en getGameState-metod (enligt tips från mos), som
                    jag använde när jag testade metoderna i game-klassen. "Problemet" med game-
                    klassen var ju dock att flera metoder anropades även om jag bara ville testa
                    en av dem. getGameState-metoden fyllde ett visst syfte, men jag vet inte om
                    hela test-suiten bara blev ett korthus, ett fejkat test för att nå högre
                    kodtäckning. En sak jag gjorde för att ändå få lite mindre variation i
                    testningen var att uppdatera shuffle-metoden i Deck-klassen med en
                    optionell parameter "seed" som gjorde att kortleken alltid blandades på exakt
                    samma sätt så länge seed-värdet var samma. På så vis kunde jag också lätt
                    simulera ess på hand och andra metoder i övriga klasser.
                </p>
                <p>
                    Testbar kod kan absolut vara en markör för snygg och ren kod.
                    Genom att till exempel inte chaina mina metoder i game-klassen och
                    låta dem utföra sitt arbete och därefter returnera ett värde eller uppdatera
                    en property, hade det varit lättare att testa koden och det hade varit lättare
                    också att se vart koden leder.
                </p>
                <p>
                    Min TIL för detta kmom är följande: I framtiden vill jag för projekt eller
                    uppgifter (kod) som behöver testas skriva testfall innan jag börjar skriva
                    själva koden. Det hade, för mig, varit en bättre approach om jag hade jobbat
                    TDD redan från början. Nu tog jag mig inte tiden, av olika anledningar, att
                    arbeta om min kod. Det hade i och för sig varit en bra läxa, men i brist av tid
                    valde jag att inte lägga något krut på det. Må hända att jag får Ux på grund av
                    mina bristfälliga test suites och då får jag helt enkelt tänka om.
                </p>
                <p>
                    Mvh Martin
                </p>
            </section>
            <section id="kmom05">
                <h2>Kmom05</h2>
                <p>
                    Ja, det gick bra att genomföra övningen. Jag tyckte det var lätt att sätta sig
                    in i tack vare databas-kursen. Jag reagerade inte över någonting särskilt, mer
                    än att det var väldigt lätt att skapa en tabell (entity) och tabell-kolumnerna
                    med terminal-kommandon.
                </p>
                <p>
                    Jag skapade en landningssida (library) från vilken samtliga sidor i appen
                    är tillgängliga. Precis som i tidigare kursmoment, genererade jag url till
                    sidan för att använda dem i ett formulär med en knapp för varje sida i appen.
                    Jag tänkte att det ska vara enkelt att komma åt olika sidor och funktioner
                    inuti sidorna. Där skapade jag knappar för att komma till alla böcker,
                    landningssidan (main menu) och för att klicka sig mellan böcker (previous och
                    next-knappar). Jag tyckte att det behövdes en confirm delete-sida för att ge
                    användaren en chans att ångra sig innan en bok tas bort. Gränssnittet i övrigt
                    liknar resten av min symfony-applikation där mycket av stylingen är
                    återkommande. Jag hittade även unicode-karaktärer som jag använde mig av
                    i knapparnas text.
                </p>
                <p>
                    Jag tycker att det gick bra att jobba med ORM (CRUD). Nu valde jag att placera
                    all kod i min BookController. Snyggast, enligt mig, hade varit att placera
                    en del av koden i andra klasser eller bookrepot, t.ex. koden som ändrar
                    i databasen hade kunnat placeras i bookrepot och koden som jag återanvänder
                    för att fastställa föregående och nästa bok hade kunnat placeras i en egen
                    klass eller trait. CRUD i ORM var smidigt då Book-entityn automatiskt skapat
                    metoder för att "getta" och "setta" värden i tabellen. Om jag jämför det med
                    databas-kursen och webtec-kursen, fick vi skriva alla förfrågningar mot databasen
                    från grunden. ORM-approachen kapar en del mellansteg, vilket skapar en effektivare
                    process. Om jag vill ha fler metoder än de som erbjuds i entity-klassen eller
                    repot, kan jag enkelt lägga till dem.
                </p>
                <p>
                    ORM verkar kanon än så länge och det ska bli kul att lära sig mer om det i
                    prjektet! All kod vi behövde skriva i databas-kursen (både sql och javascript),
                    är ju klart minimerat tack vare ORM-sättet att arbeta med en databas. Jag ville
                    verkligen lyckas kicka igång mariadb istället för sqlite, men jag fick inte riktigt
                    till det. Tycker att sqlite fungerade tillräckligt bra för den här rundan.
                </p>
                <p>
                    Min TIL för den här veckan är doctrine/orm och förståelsen för hur alla auto-
                    magiskt skapade filer hänger ihop. Det var även kul att skapa logiken bakom
                    previous och next book.
                </p>
                <p>
                    Mvh Martin
                </p>
            </section>
            <section id="kmom06">
                <h2>Kmom06</h2>
                <p>
                    Det var svårt till en början att förstå alla mått och få grepp om
                    metrics-rapporten. Jag försökte fokusera på 6C som uppgiften handlade om, vilket
                    gjorde det lättare. När det väl hade lossnat kunde jag lättare hitta rätt mått
                    och analysera rapporten. Metrics-verktyget gav inte lika handfasta tips som
                    scrutinizer, men genom att läsa på om de olika värdena var det inte svårt
                    att hitta lämpliga åtgärder. Det jag mest uppskattade med verktyget var ändå
                    bilden med de olika klasserna visualiserade som gröna, gula och röda bollar.
                    Bilden gav en överblick och känsla för vilka delar av koden som var mest akuta
                    att jobba med.
                </p>
                <p>
                    Det gick ändå ok att få till Scrutinizer. Det failade några gånger innan jag hittade
                    en webbsida som förklara vad jag skulle göra åt failen. Min känsla är att
                    Scrutinizer inte är lika heltäckande som phpmetrics, vilket gjorde verktyget lite
                    lättare att förstå och rapporten lättare att hitta i. Det var roligt att få min
                    kod "bedömd", jag fick en känsla för om jag hade gjort ett bra jobb från början
                    eller inte. Scrutinizer var lite snällare i sin bedömning tycker jag, det lyste
                    mer rött i phpmetrics.
                    Jag landade på över 9 i kodkvalitet och strax över 70% i kodtäckning efter
                    första bygget. Efter sista bygget landade jag på 10 respektive 78%.
                </p>
                <p>
                    EDIT! Insåg att jag hade glömt att ta bort exkluderingen av src/Controller.
                    Inte konstigt att kodtäckningen var så hög. Exkluderade dock src/Entity och
                    src/Repository, för tillfället i alla fall. Inför projektinlämningen är min
                    ambition att nå högre kodtäckning i src/Controller till att börja med.
                    Kanske ger jag mig på att göra enhetstester även för Entity- och
                    Repository-klasserna. Med denna ändring landar kodtäckningen för min del på
                    blygsamma 37%.
                </p>
                <p>
                    Eftersom jag har arbetat själv genom alla kurser, har jag inte reflekterat särskilt
                    mycket kring kodkvalitet och snygg kod. Däremot förstår jag att det är en
                    särskilt viktig aspekt i utveckling av programvara när en jobbar i ett team,
                    oavsett litet eller stor. Vikten av att koden är lättläst och lättförståelig ökar
                    med storleken på ett projekt och antalet människor som arbetar inom projektet.
                    Gemensam kodstil, testbar kod, linters och analysverktyg måste vara del av alla
                    projekt. Jag tänker att det bara leder till ett effektivare arbete, mindre
                    efterarbete och minskad risk för koststamma buggar i produktion.
                </p>
                <p>
                    Min TIL för det här kursmomentet är hur jag kan använda Scrutinizer och PHPMetrics
                    för att analysera och förbättra min kod.
                </p>
            </section>
            <section id="kmom10">
                <h2>Kmom10</h2>
                <p>Text</p>
            </section>
            <a href="{{ path('report') }}#header">
                <h3>Upp till toppen</h3>
            </a>
        </div>
        <div class="report-links">
            <h3 class="sections">Avsnitt</h3>
            <div class="report-link">
                <a href="{{ path('report') }}#kmom01">kmom01</a>
                <a href="{{ path('report') }}#kmom02">kmom02</a>
                <a href="{{ path('report') }}#kmom03">kmom03</a>
                <a href="{{ path('report') }}#kmom04">kmom04</a>
                <a href="{{ path('report') }}#kmom05">kmom05</a>
                <a href="{{ path('report') }}#kmom06">kmom06</a>
                <a href="{{ path('report') }}#kmom10">kmom10</a>
            </div>
        </div>
    </div>
{% endblock %}